#!/bin/bash
set -euo pipefail
set -x

cleanup_vagrant_leftovers() {
  echo "Cleaning up Vagrant leftovers (if any)"
  set +e
  # TODO(cmaloney): Move to killing in virtualbox dirrectly? (rm -rf "~/VirtualBox VMs")
  vagrant destroy -f

  set +e
  for box in $( vboxmanage list vms | grep .dcos | cut -d '{' -f 2 | tr -d '}' ); do
    vboxmanage controlvm "$box" poweroff
    vboxmanage unregistervm "$box" --delete;
  done
  set -e

  vagrant global-status --prune
  set -e
}

echo "Fetching dcos-vagrant"

# Get the dcos-vagrant
# TODO(cmaloney): Have TeamCity do this for us.
# If it already exists, fetch, otherwise clone
if [ ! -d dcos-vagrant ]; then
  git clone git@github.com:mesosphere/dcos-vagrant.git
else
  git -C dcos-vagrant fetch origin -t +refs/heads/*:refs/remotes/origin/*
fi

# Pin to just the right dcos-vagrant commit
git -C dcos-vagrant checkout -qf ff40e88dffd4dd0fb190b02e750fde64ca8f5bc7

cp ../dcos_generate_config.sh dcos-vagrant/dcos_generate_config.sh

cd dcos-vagrant

# Make sure we're running inside the test directory which contains the Vagrantfile
if [ ! -f Vagrantfile ]
then
  echo "Expected a Vagrantfile inside the dcos-vagrant repo"
  exit 1
fi

# Flag used so TeamCity can tell if the build passed or failed. On failure,
# TeamCity will get logs from vagrant if possible then cleanup all artifacts.
rm -rf PASSED

export MASTER_IP=192.168.65.90
export DCOS_DNS_ADDRESS=http://$MASTER_IP

cp VagrantConfig.yaml.example VagrantConfig.yaml
export DCOS_CONFIG_PATH="etc/3_master.yaml"
export DCOS_BOOT_NODE_DOCKER_REGISTRY="true"
cat <<EOF > "$DCOS_CONFIG_PATH"
---
cluster_name: test_cluster
bootstrap_url: http://boot.dcos
dns_search: mesos
exhibitor_storage_backend: zookeeper
exhibitor_zk_hosts: 192.168.65.50:2181
exhibitor_zk_path: /zk-shared
master_discovery: static
master_list:
  - 192.168.65.90
  - 192.168.65.95
  - 192.168.65.101
EOF

cleanup_vagrant_leftovers

echo "Starting Vagrant VMs"
vagrant up boot m1 m2 m3 w1 w2

# TODO(cmaloney): Configure insecure registry inside the dcos-vagrant cluster

# Prep for the integration test after vagrant up so that it happens in parallel
# with DCOS assembling itself to save some time.
# Build a docker container for running py.test inside of.
echo "Building py.test container"
docker build -t py.test - < ../../docker/py.test/Dockerfile

# Build and push test server to local registry:
echo "Building&pushing test_server container"
docker build -t 127.0.0.1:5000/test_server -f ../../docker/test_server/Dockerfile ../../docker/test_server/

# Make an ssh tunnel to the vagrant machine then push the container over it to get around
# host insecure registry setting...
vagrant ssh boot -- -N -L 5000:192.168.65.50:5000 -f && docker push 127.0.0.1:5000/test_server

echo "Running integration test"
docker run -v $PWD/../../integration_test.py:/integration_test.py \
    -e DCOS_DNS_ADDRESS=$DCOS_DNS_ADDRESS \
    -e MASTER_HOSTS="192.168.65.90,192.168.65.95,192.168.65.101" \
    -e SLAVE_HOSTS="192.168.65.111,192.168.65.121" \
    -e REGISTRY_HOST="boot.dcos" \
    -e "TEAMCITY_VERSION=${TEAMCITY_VERSION:-}" \
    -e "DNS_SEARCH=true" \
    --net=host py.test py.test -vv -s ${CI_FLAGS:-} /integration_test.py
RET=$?

if [ $RET -ne 0 ]; then
  echo "TEST FAILED"
  exit 1
fi

echo "Cleaning up vagrant"
vagrant destroy -f

touch PASSED
