#!/bin/bash
set -x

# Setup go environment
mkdir -p /go/src/github.com/mesosphere
ln -s /pkg/src/mesos-dns /go/src/github.com/mesosphere/mesos-dns
export GOPATH=/go
export GOROOT=/pkg/src/go/
export PATH=$PATH:$GOROOT/bin:$GOPATH/bin

# Get the dependencies
go get github.com/tools/godep

# Build mesos-dns
pushd /go/src/github.com/mesosphere/mesos-dns
make build
popd

# TODO(cmaloney): PKG_PATH should always exist in the container
# Install to pkg-path
mkdir -p $PKG_PATH/bin
cp /go/src/github.com/mesosphere/mesos-dns/mesos-dns $PKG_PATH/bin/mesos-dns


# Create the service file
service="$PKG_PATH/dcos.target.wants_master/mesos-dns.service"
mkdir -p "$(dirname "$service")"
cat <<EOF > "$service"
[Unit]
Description=Mesos DNS
After=network.target
[Service]
Restart=on-failure
StartLimitInterval=0
RestartSec=5
EnvironmentFile=/etc/environment
EnvironmentFile=/opt/mesosphere/environment
ExecStart=/opt/mesosphere/bin/mesos-dns --config=/opt/mesosphere/etc/mesos-dns.json -logtostderr=true -v=2
EOF

for role in master slave
do
resolvconf_service="$PKG_PATH/dcos.target.wants_$role/gen_resolvconf.service"
mkdir -p "$(dirname "$resolvconf_service")"
cat <<'EOF' > "$resolvconf_service"
[Unit]
Description=Update systemd-resolved for mesos-dns
[Service]
Type=simple
EnvironmentFile=/etc/environment
EnvironmentFile=/opt/mesosphere/environment
EnvironmentFile=/opt/mesosphere/etc/cloudenv
ExecStart=/opt/mesosphere/bin/gen_resolvconf.py "${MASTER_ELB}" "${FALLBACK_DNS}" /etc/resolv.conf
EOF
done

for role in master slave
do
resolvconf_timer="$PKG_PATH/dcos.target.wants_$role/gen_resolvconf.timer"
mkdir -p "$(dirname "$resolvconf_timer")"
cat <<'EOF' > "$resolvconf_timer"
[Unit]
Description=Periodically update systemd-resolved for mesos-dns
[Timer]
OnBootSec=0min
OnUnitActiveSec=1min
Unit=gen_resolvconf.service
EOF
done

gen_resolvconf="$PKG_PATH/bin/gen_resolvconf.py"
cat <<'EOF' > "$gen_resolvconf"
#!/opt/mesosphere/bin/python

import socket
import subprocess
import sys
import json
import codecs
import urllib.request

import dns.query


EXHIBITOR_STATUS_URL = 'http://{}:8181/exhibitor/v1/cluster/status'


if len(sys.argv) != 4:
    print('Usage: gen_resolvconf.py MASTER_ADDRESS FALLBACK_DNS RESOLV_CONF_PATH', file=sys.stderr)
    print('Received: {}'.format(sys.argv), file=sys.stderr)
    sys.exit(-1)
status_url = EXHIBITOR_STATUS_URL.format(sys.argv[1])
fallback_dns = sys.argv[2]
resolvconf_path = sys.argv[3]
dns_test_query = 's3.amazonaws.com'
dns_timeout = 5

servers = []

try:
    response = urllib.request.urlopen(status_url)
    reader = codecs.getreader("utf-8")
    data = json.load(reader(response))
    for node in data:
        try:
            addr = socket.gethostbyname(node['hostname'])
            query = dns.message.make_query(dns_test_query, dns.rdatatype.ANY)
            result = dns.query.udp(query, addr, dns_timeout)
            if len(result.answer) == 0:
                print('Skipping DNS server {}: no records for {}'.format(addr, dns_test_query), file=sys.stderr)
            else:
                servers.append(addr)
        except socket.gaierror as ex:
            print(ex, file=sys.stderr)
        except dns.exception.Timeout:
            print('Skipping DNS server {}: no response'.format(addr), file=sys.stderr)
except:
    print('Error getting DNS entries from {}: {}'.format((status_url), sys.exc_info()[1]), file=sys.stderr)

# Use maximum of three servers per resolv.h MAXNS, with the known good fallback
# dns server always present as the last in the set.
nameservers = servers[:2]
nameservers.append(fallback_dns)

print('Updating {}'.format(resolvconf_path))
with open(resolvconf_path, 'w') as f:
    for ns in nameservers:
        line = "nameserver {}".format(ns)
        print(line, file=sys.stderr)
        print(line, file=f)

sys.exit(0)
EOF
chmod +x "$gen_resolvconf"
